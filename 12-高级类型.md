# 高级类型

> 所谓高级类型，就是 `ts` 为了保障语言的灵活性所引入的语言特性。这些特性有助于我们应对复杂多变的开发场景。

## 交叉类型

> 交叉类型是将多个类型合并为一个类型。它包含了所需的所有类型的特性。 （合集）
> 我们大多是在混入（`mixins`）或其它不适合典型面向对象模型的地方看到交叉类型的使用。

```ts
interface DogInterface {
  run(): void;
}
interface CatInterface {
  jump(): void;
}
let pet: DogInterface & CatInterface = { run() {}, jump() {} };
```

## 联合类型

> 联合类型表示一个值可以是几种类型之一。
> 如果一个值是联合类型，我们只能访问此联合类型的所有类型里**共有的成员**。

```ts
let a: number | string = "string"; // ok!
a = 1; // ok!
```

- **字面量联合类型**
  > 字面量类型：`ts` 提供的一个准确变量
  ```ts
  let b: 1 | "2" | true = 1; // ok!
  b = false; // error!
  ```
- **对象联合类型**
  ```ts
  class Dog implements DogInterface {
    run() {}
    eat() {}
  }
  class Cat implements CatInterface {
    jump() {}
    eat() {}
  }
  enum Master {
    Boy,
    Girl,
  }
  function getPet(master: Master) {
    let pet = master === Master.Boy ? new Dog() : new Cat();
    pet.eat(); // ok!
    pet.jump(); // error!
    return pet;
  }
  ```
- **可区分的联合类型**

  > 结合了联合类型和字面量类型的类型保护方法。
  > 如果一个类型是多个类型的联合类型，并且多个类型之间有公共属性，那么我们可以凭借这个公共属性创建类型保护区块。

  ```ts
  // 计算不同图形的面积

  interface Square {
    kind: "square";
    size: number;
  }

  interface Rectangle {
    kind: "rectangle";
    width: number;
    height: number;
  }

  function computedArea(shape: Square | Rectangle) {
    switch (shape.kind) {
      case "square":
        return shape.size * shape.size;
      case "rectangle":
        return shape.width * shape.height;
    }
  }
  ```

  这时，我希望增加一个 `圆形`，会出现隐患。

  ```ts
  interface Circle {
    kind: "circle";
    r: number;
  }
  function computedArea(shape: Square | Rectangle | Circle) {
    ...
  }
  computedArea({ kind: "circle", r: 1 }); // undefinded
  ```

  这时并没有给出错误提示。约束方案有二：

  - **指定明确返回值类型**
    ```ts
    type Shape = Square | Rectangle | Circle;
    function computedArea(shape: Shape): number {
      switch (shape.kind) {
        case "square":
          return shape.size * shape.size;
        case "rectangle":
          return shape.width * shape.height;
        case "circle":
          return Math.PI * shape.r ** 2;
      }
    }
    ```
  - **利用 `never` 类型**
    ```ts
    function computedArea(shape: Shape) {
      switch (shape.kind) {
        case "square":
          return shape.size * shape.size;
        case "rectangle":
          return shape.width * shape.height;
        case "circle":
          return Math.PI * shape.r ** 2;
        default:
          return ((e: never) => {
            throw new Error(e);
          })(shape);
      }
    }
    ```
    检查 `shape` 是否是 `never` 类型；当 `case` 完全覆盖时，`shape` 是 `never` 类型；反之，需要补全分支。

## 索引类型
